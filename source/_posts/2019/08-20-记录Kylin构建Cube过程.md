---
title: 记录Kylin构建Cube过程
tags:
  - 随笔
categories:
  - 随笔
date: 2019-08-20 20:49:10
---
# Kylin构建Cube过程
> 面试的时候遇到了类似的问题，但是没有很好的回答。当初也只是在使用的层面，没有好好理解，现在做笔记记录

{%asset_img kylin架构.jpeg kylin架构.jpeg %}

## 设计Cube
如果数据已经在Hive中准备好了，那么就可以开始设计和创建Cube了

### 导入Hive表定义
- Kylin会使用Hive的API从Hive中获取表的属性 信息。
- Kylin会在后台触发一个MapReduce任务，计算此表每个列的 基数。（HyperLogLog算法）
### 创建数据模型
- 有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模 型是Cube的基础，它主要用于描述一个星形模型。
- 选择一个事实表（必需的），然后添加 维度表（可选）
- 添加维度表的时候，需要选择连接的类型：是Inner还是Left，然后选 择连接的主键和外键，这里也支持多主键
- 选择度量列时，度量只能来自事实表
- 过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设 置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。

## 构建Cube

- 选择Cube的维度。
- 创建度量。Kylin默认会创建一个Count（1）的度量。Kylin支持的度量有：SUM、MIN、 MAX、COUNT、COUNT DISTINCT、TOP_N、RAW等。
- 选择需要的度量 类型，然后再选择适当的参数
- Kylin默认会把所有维度都放在同一个聚合组中；如果维度数较多（例 如>10），建议将维度分为多个聚合组
> 可用于Kylin的构建优化：如果一个Cube有（M+N）个维度， 那么默认它会有$2^{m+n}$ 个Cuboid；如果把这些维度分为两个不相交的聚合 组，那么Cuboid的数量将被减少为$2^m +2^n$ 
- 将过滤频率较高的 列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之 前。
> 可用于Kylin的查询优化：频率较高的 列放置在过滤频率较低的列之前，可以充分利用过滤条件来缩小在HBase中扫描的范围， 从而提高查询的效率。

### Cube的构建
包含如下步骤，由Kylin任务引擎来调度执行。

1-5为计算Cube而做的准备工作
1. 创建临时的Hive平表（从Hive读取数据）。 
2. 计算各维度的不同值，并收集各Cuboid的统计数据。 
3. 创建并保存字典。
4. 保存Cuboid统计信息。 
5. 创建HTable。 

6. 计算Cube（一轮或若干轮MapReduce）。是真正的Cube 计算，取决于所使用的Cube算法，它可能是一轮MapReduce任务，也可能 是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的 MapReduce。
7. 将Cube的计算结果转成HFile。将这些结果转换成 HFile（HBase文件存储格式）。
8. 加载HFile到HBase。通过使用HBase BulkLoad工具，将 HFile导入进HBase集群，这一步完成之后，HTable就可以查询到数据了。
9. 更新Cube元数据。将此次构建的Segment的状态从“NEW”更新 为“READY”，表示已经可供查询了；
10. 垃圾回收。清理构建过程中生成的临 时文件等垃圾，释放集群资源。

## 数据在Kylin中的存储（老是被问到，哈哈）

*|Row Key|(维度选择)|*|-|Metrics|(指标)|*|
---|---|---|---|---|---|---|---
选择的维度为1|D1|D2|D2|-|M1|M2|M3
00010101|a1|c1|e1|-|101|201|301
00010101|a2|c2|e2|-|200|400|600

- 在查询中被用作过滤条件的维度有可能放在其他维度的前面。 
- 将经常出现在查询中的维度放在不经常出现的维度的前面。 ·
- 对于基数较高的维度，如果查询会有这个维度上的过滤条件,那么 将它往前调整；如果没有，则向后调整。

## 构建算法

- layered cubing，也称逐层算法：它是逐层由底向上，把所有组合算完的过程。
  {%asset_img layeredcubing.jpeg layeredcubing.jpeg %}
  
>如图是一个四维Cube，有维度A、B、C、D；它会需要五轮的Map－Reduce来完成：第一轮MR的输入是源数据， 这一步会对维度列的值进行编码，并计算ABCD组合的结果。接下来的MR以上一轮的输出为输入，向上聚合计算三个维度的组合： ABC, BCD, ABD, 和ACD；依此类推，直到算出所有的维度组合。

> 这个算法的优势是每一轮MR以上一轮的输出为结果，这样可以减少重复结算；当计算到后半程的时候，随着数据的减小，计算会越来越快 。 逐层Cube算法的主要优点是简单：Cube聚合的过程就是把要聚合掉的维度从key中减掉组成新的key交给Map-Reduce，由Map-Reduce框架对新key做排序和再聚合，计算结果写到HDFS。这个算法很好地利用了Map-Reduce框架。得益于Hadoop/Map－Reduce的成熟，此算法的稳定性已经非常高。